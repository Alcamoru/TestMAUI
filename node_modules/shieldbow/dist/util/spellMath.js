"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.performMath = exports.multiply = exports.arrToString = exports.round = void 0;
const fnv1a_1 = require("./fnv1a");
const constants_1 = require("./constants");
/**
 * Rounds the value to up to 2 decimal points.
 * @param value - The value that needs to be rounded off.
 */
function round(value) {
    const m = Number((Math.abs(value) * 100).toPrecision(15));
    return Math.round(m) / 100;
}
exports.round = round;
/**
 * Parses the float values and returns rounded strings.
 * @param values - The numerical values to parse.
 */
function arrToString(values) {
    return values.map((v) => round(v).toString());
}
exports.arrToString = arrToString;
/**
 * Parses values and returns a string displaying them in appropriate format.
 * @param values - The numerical values to parse.
 * @param maxRank - The highest spell rank applicable.
 */
function getJoined(values, maxRank) {
    return values.slice(1, maxRank + 1).every((v) => v === values[1])
        ? values[1].toString()
        : arrToString(values.slice(1, maxRank + 1)).join('/');
}
const numberPart = (part, options = { percent: false }) => {
    const n = round(part.mNumber * (options.percent ? 100 : 1));
    if (n > 0)
        return n.toString() + (options.percent ? '%' : '');
    return '0';
};
const effectValuePart = (part, effects, level = -1, maxRank, options = { percent: false }) => {
    const values = effects[part.mEffectIndex - 1].value.map((v) => round(v * (options.percent && v < 1 ? 100 : 1)));
    return level > -1
        ? effects[part.mEffectIndex - 1].value[level].toString()
        : getJoined(values, maxRank) + (options.percent ? '%' : '');
};
const dataValuePart = (part, data, level = -1, maxRank, options = { percent: false }) => {
    const valueName = part.mDataValue.toLowerCase();
    const key = Object.keys(data).find((k) => {
        const hashed = `{${(0, fnv1a_1.hash)(k)}}`;
        if (k === valueName || hashed === valueName)
            return k;
        else
            return;
    });
    if (key) {
        const currentValue = data[key].map((n) => round(n * (options.percent ? 100 : 1)));
        return ((level > -1 ? currentValue[level].toString() : getJoined(currentValue, maxRank) + (options.percent ? '%' : '')) ||
            '?');
    }
    return '?';
};
const statByCoefficientPart = (part, options = { percent: false }) => {
    let coefficient = round(part.mCoefficient * 100 * (options.percent ? 100 : 1));
    if (coefficient > 1000) {
        coefficient = round(coefficient / 100);
        options = { percent: false };
    }
    const statType = constants_1.StatFormula[part.mStatFormula - 1];
    const statName = constants_1.Stat[part.mStat];
    if (coefficient)
        return `${coefficient}%${options.percent ? ' per 100' : ''}${statType ? ` ${statType}` : ''} ${statName || 'AP'}`;
    return '?';
};
const resourceByCoefficientPart = (part) => {
    const coefficient = round(part.mCoefficient * 100).toString();
    if (coefficient)
        return `${coefficient}% of the maximum mana`;
    return '?';
};
const statByDataValuePart = (part, data, level = -1, maxRank, options = { percent: false }) => {
    const statType = constants_1.StatFormula[part.mStatFormula - 1];
    const statName = constants_1.Stat[part.mStat];
    const valueName = part.mDataValue.toLowerCase();
    const key = Object.keys(data).find((k) => {
        const hashed = `{${(0, fnv1a_1.hash)(k)}}`;
        if (k === valueName || hashed === valueName)
            return k;
        else
            return;
    });
    if (key) {
        const currentValue = data[key].map((n) => n * (options.percent ? 10000 : 100)).map((n) => round(n));
        const coefficient = (level > -1 ? currentValue[level].toString() : getJoined(currentValue, maxRank)) || '?';
        return `${coefficient}%${options.percent ? ' per 100' : ''}${statType ? ` ${statType}` : ''} ${statName || 'AP'}`;
    }
    return '?';
};
const parseBreakpoints = (breakpoints) => {
    const result = {};
    for (const breakpoint of breakpoints)
        if (breakpoint) {
            let value = 0;
            for (const key of Object.keys(breakpoint))
                if (key !== '__type' && key !== 'mLevel')
                    value = round(breakpoint[key]);
            const level = parseInt(breakpoint.mLevel);
            result[level] = value;
        }
    return result;
};
const byChampLevelBreakpointsPart = (part, options = { percent: false }) => {
    const base = round(part.mLevel1Value || 0);
    const breakpoints = parseBreakpoints(part.mBreakpoints || []);
    let scale = 0;
    let max = base;
    for (const key of Object.keys(part))
        if (!['mLevel1Value', 'mBreakpoints', '__type'].includes(key))
            scale = round(part[key]);
    for (let i = 1; i < 18; i++) {
        if (breakpoints[i + 1] !== undefined)
            scale = breakpoints[i + 1];
        max += scale;
    }
    max = round(max);
    if (max === base)
        return `${base}`;
    return `${base * (options.percent ? 100 : 1)}${options.percent ? '%' : ''} - ${max * (options.percent ? 100 : 1)}${options.percent ? '%' : ''} (based on champion level)`;
};
const byChampLevelInterpolationPart = (part, options = { percent: false }) => {
    const start = round(part.mStartValue || 0) * (options.percent ? 100 : 1);
    const end = round(part.mEndValue || 0) * (options.percent ? 100 : 1);
    return `${start}${options.percent ? '%' : ''} - ${end}${options.percent ? '%' : ''} (based on champion level)`;
};
const productParts = (part1, part2) => {
    if (isNaN(parseFloat(part1)) && isNaN(parseFloat(part2)))
        return `${part1} + ${part2}`;
    const part1Num = part1.match(/[^\d.]/g)?.length ? NaN : parseFloat(part1);
    const part2Num = part2.match(/[^\d.]/g)?.length ? NaN : parseFloat(part2);
    if (isNaN(part1Num) && isNaN(part2Num))
        return `${part1} * (${part2})`;
    let index = 0;
    if (isNaN(part1Num)) {
        let result = part1;
        const numbers = part1.match(/[\d.]+/g) || [];
        const newNs = numbers.map((n) => parseFloat(n)).map((n) => round(n * part2Num));
        for (let i = 0; i < numbers.length; i++) {
            const constant = result.substring(0, index);
            const toReplace = result.substring(index);
            const toAdd = toReplace.indexOf(numbers[i]);
            if (!toReplace.substring(0, toAdd).trim().endsWith('per'))
                result = constant + toReplace.replace(numbers[i], newNs[i].toString());
            else
                result = constant + toReplace;
            index += toAdd + newNs[i].toString().length;
        }
        return result;
    }
    else {
        let result = part2;
        const numbers = part2.match(/[\d.]+/g) || [];
        const newNs = numbers.map((n) => parseFloat(n)).map((n) => round(n * part1Num));
        for (let i = 0; i < numbers.length; i++) {
            const constant = result.substring(0, index);
            const toReplace = result.substring(index);
            const toAdd = toReplace.indexOf(numbers[i]);
            if (!toReplace.substring(0, toAdd).trim().endsWith('per'))
                result = constant + toReplace.replace(numbers[i], newNs[i].toString());
            else
                result = constant + toReplace;
            index += toAdd + newNs[i].toString().length;
        }
        return result;
    }
};
const sumParts = (part1, part2) => {
    if (isNaN(parseFloat(part1)) && isNaN(parseFloat(part2)))
        return `${part1} + ${part2}`;
    const part1Num = part1.match(/[^\d.]/g)?.length ? NaN : parseFloat(part1);
    const part2Num = part2.match(/[^\d.]/g)?.length ? NaN : parseFloat(part2);
    if (Object.keys(constants_1.Stat).some((k) => part1.includes(k) || part2.includes(k))) {
        if (part1 === '0')
            return part2;
        if (part2 === '0')
            return part1;
        return `${part1} + ${part2}`;
    }
    if (isNaN(part1Num) && isNaN(part2Num))
        return '0';
    let index = 0;
    if (isNaN(part1Num)) {
        let result = part1;
        const numbers = part1.match(/[\d.]+/g) || [];
        const newNs = numbers.map((n) => parseFloat(n)).map((n) => round(n + part2Num));
        for (let i = 0; i < numbers.length; i++) {
            const constant = result.substring(0, index);
            const toReplace = result.substring(index);
            const toAdd = toReplace.indexOf(numbers[i]);
            result = constant + toReplace.replace(numbers[i], newNs[i].toString());
            index += toAdd + newNs[i].toString().length;
        }
        return result;
    }
    else {
        let result = part2;
        const numbers = part2.match(/[\d.]+/g) || [];
        const newNs = numbers.map((n) => parseFloat(n)).map((n) => round(n + part1Num));
        for (let i = 0; i < numbers.length; i++) {
            const constant = result.substring(0, index);
            const toReplace = result.substring(index);
            const toAdd = toReplace.indexOf(numbers[i]);
            result = constant + toReplace.replace(numbers[i], newNs[i].toString());
            index += toAdd + newNs[i].toString().length;
        }
        return result;
    }
};
const statSubpartPart = (sub, part) => {
    const statType = constants_1.StatFormula[part.mStatFormula - 1];
    const statName = constants_1.Stat[part.mStat];
    const numbers = sub.match(/[\d.]+/g) || [];
    const newNs = numbers.map((n) => round(parseFloat(n) * 100));
    for (let i = 0; i < numbers.length; i++)
        sub = sub.replace(numbers[i].toString(), newNs[i].toString());
    return `(${sub})%${statType ? ` ${statType}` : ''} ${statName || 'AP'}`;
};
/**
 * Multiplies two spell calculation parts.
 * @param part1 - The first part.
 * @param part2 - The second part.
 */
function multiply(part1, part2) {
    if (part2.match(/^\d+%$/)?.length)
        part2 = round(parseFloat(part2) / 100).toString();
    return productParts(part1, part2);
}
exports.multiply = multiply;
/**
 * A function that takes in calculations and performs the necessary operations to generate appropriate tooltips.
 * @param calculation - The calculations.
 * @param effects - The effect values.
 * @param datavalue - The named data values.
 * @param maxRank - The max applicable spell rank.
 * @param options - Additional spell math options.
 */
function performMath(calculation, effects, datavalue, maxRank, options) {
    if (!calculation?.__type)
        return '0';
    switch (calculation.__type) {
        case 'EffectValueCalculationPart':
            return effectValuePart(calculation, effects, -1, maxRank, options);
        case 'NumberCalculationPart':
            return numberPart(calculation, options);
        case 'NamedDataValueCalculationPart':
            return dataValuePart(calculation, datavalue, -1, maxRank, options);
        case 'StatByCoefficientCalculationPart':
            return statByCoefficientPart(calculation, options);
        case 'AbilityResourceByCoefficientCalculationPart':
            return resourceByCoefficientPart(calculation);
        case 'StatByNamedDataValueCalculationPart':
            return statByDataValuePart(calculation, datavalue, -1, maxRank, options);
        case 'ByCharLevelBreakpointsCalculationPart':
            return byChampLevelBreakpointsPart(calculation, options);
        case 'ByCharLevelInterpolationCalculationPart':
            return byChampLevelInterpolationPart(calculation, options);
        case 'CooldownMultiplierCalculationPart':
            return '1';
        case 'ProductOfSubPartsCalculationPart':
            const productPart1 = performMath(calculation.mPart1, effects, datavalue, maxRank, options);
            const productPart2 = performMath(calculation.mPart2, effects, datavalue, maxRank, options);
            return productParts(productPart1, productPart2);
        case 'SumOfSubPartsCalculationPart':
            const sumPart1 = performMath(calculation.mSubparts[0], effects, datavalue, maxRank, options);
            const sumPart2 = performMath(calculation.mSubparts[1], effects, datavalue, maxRank, options);
            return sumParts(sumPart1, sumPart2);
        case 'StatBySubPartCalculationPart':
            const sub = performMath(calculation.mSubpart, effects, datavalue, maxRank, options);
            return statSubpartPart(sub, calculation);
        case 'BuffCounterByNamedDataValueCalculationPart':
            const value = dataValuePart(calculation, datavalue, -1, maxRank, options);
            const dataBuff = calculation.mBuffName.startsWith('{') ? '?' : calculation.mBuffName;
            return `${value} per stack of ${dataBuff}`;
        case 'BuffCounterByCoefficientCalculationPart':
            const buffCoeff = round(calculation.mCoefficient * (options.percent ? 100 : 1));
            const coeffBuff = calculation.mBuffName.startsWith('{') ? '?' : calculation.mBuffName;
            return `${buffCoeff}${options.percent ? '%' : ''} per stack of ${coeffBuff}`;
        default:
            return '?';
    }
}
exports.performMath = performMath;
//# sourceMappingURL=spellMath.js.map