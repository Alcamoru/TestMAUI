"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalStorage = void 0;
const tslib_1 = require("tslib");
const collection_1 = require("@discordjs/collection");
const node_path_1 = tslib_1.__importDefault(require("node:path"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
/**
 * A basic storage plugin that stores data to the local file system.
 */
class LocalStorage {
    /**
     * Creates a new LocalStorage instance.
     * @param client - The client to use.
     * @param root - The root path to use.
     */
    constructor(client, root) {
        Object.defineProperty(this, "_pathName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "cache", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this._pathName = node_path_1.default.join(process.cwd(), root);
        this.cache = new collection_1.Collection();
    }
    /**
     * Fetches a value from storage.
     * @param id - The file name of the value to fetch.
     * @param key - The path to the value to fetch.
     */
    async fetch(key, id) {
        return new Promise((resolve, reject) => {
            if (this.cache.has(key + id))
                resolve(this.cache.get(key + id));
            key = node_path_1.default.join(...key.split(':'));
            const contentPath = node_path_1.default.join(this._pathName, key, id + '.json');
            const exists = fs_extra_1.default.existsSync(contentPath);
            this.client.logger?.trace(`(Local fetch) File path: ${contentPath}, exists: ${exists}.`);
            if (!exists)
                reject('File does not exist.');
            else {
                const content = fs_extra_1.default.readFileSync(contentPath).toString();
                if (content.trim().length === 0) {
                    // Detect file corruption #6
                    fs_extra_1.default.unlinkSync(contentPath);
                    reject('File is empty.');
                }
                else
                    try {
                        resolve(JSON.parse(content));
                    }
                    catch (e) {
                        reject(`Invalid JSON file in cache encountered: ${contentPath}`);
                    }
            }
        });
    }
    /**
     * Deletes a value from storage.
     * @param key - The path to the value to delete.
     * @param id - The file name of the value to delete.
     */
    remove(key, id) {
        key = node_path_1.default.join(...key.split(':'));
        const contentPath = node_path_1.default.join(this._pathName, key, id + '.json');
        const exists = fs_extra_1.default.existsSync(contentPath);
        this.client.logger?.trace(`(Local remove) File path: ${contentPath}, exists: ${exists}.`);
        if (exists)
            fs_extra_1.default.unlinkSync(contentPath);
    }
    /**
     * Saves a value to storage.
     * @param value - The value to save.
     * @param key - The path to the value to save.
     * @param id - The file name of the value to save.
     */
    async save(value, key, id) {
        return new Promise((resolve) => {
            key = node_path_1.default.join(...key.split(':'));
            const contentPath = node_path_1.default.join(this._pathName, key, id + '.json');
            const exists = fs_extra_1.default.existsSync(contentPath);
            this.client.logger?.trace(`(Local save) File path: ${contentPath}, exists: ${exists}.`);
            if (exists) {
                // This should not happen, but just in case.
                // v1 used to throw an error here. In v2, we will just overwrite the file.
                // This is because the file may have been corrupted, and we want to make sure.
                this.client.logger?.warn(`(Local save) File already exists: ${contentPath}. This should not happen.
        If you can reproduce this, please enable logging at 'TRACE' level and create a GitHub issue and paste the trace there.`);
                fs_extra_1.default.unlinkSync(contentPath);
            }
            fs_extra_1.default.ensureFileSync(contentPath);
            fs_extra_1.default.writeFileSync(contentPath, JSON.stringify(value, null, 2));
            this.cache.set(key + id, value);
            resolve(value);
        });
    }
    async search(key, query) {
        return new Promise((resolve, reject) => {
            key = node_path_1.default.join(...key.split(':'));
            const contentPath = node_path_1.default.join(this._pathName, key);
            const exists = fs_extra_1.default.existsSync(contentPath);
            this.client.logger?.trace(`(Local search) File path: ${contentPath}, exists: ${exists}.`);
            const result = [];
            if (!exists)
                resolve(result);
            else {
                for (const file of fs_extra_1.default.readdirSync(contentPath)) {
                    const content = JSON.parse(fs_extra_1.default.readFileSync(node_path_1.default.join(contentPath, file)).toString());
                    if (content) {
                        let found = true;
                        for (const [k, v] of Object.entries(query))
                            if (!content[k] || content[k] !== v) {
                                found = false;
                                break;
                            }
                        if (found) {
                            result.push(content);
                            break;
                        }
                    }
                }
                if (result)
                    resolve(result);
                else
                    reject('No results found.');
            }
        });
    }
}
exports.LocalStorage = LocalStorage;
//# sourceMappingURL=LocalStorage.js.map