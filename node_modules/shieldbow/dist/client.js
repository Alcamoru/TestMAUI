"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importDefault(require("axios"));
const managers_1 = require("./managers");
const ratelimiter_1 = require("./ratelimiter");
const util_1 = require("./util");
const patchRegex = /\d+\.\d+/;
/**
 * The shieldbow client that enables you to interact with Riot Games' League of Legends API.
 * Also connects to the Data Dragon + Community Dragon CDNs.
 */
class Client {
    set summonerSpells(value) {
        this._summonerSpells = value;
    }
    constructor(apiKey) {
        Object.defineProperty(this, "_cdnBase", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_versions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_summoners", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_accounts", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_leagues", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_matches", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_spectator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_challenges", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_clash", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_http", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_apiKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_initialized", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_patch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_locale", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_region", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_champions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_items", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_runes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_summonerSpells", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_api", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_seasons", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_queues", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_maps", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_gameModes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_gameTypes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_logger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_cache", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_storage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_storageEnabled", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_cacheEnabled", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._cdnBase = 'https://ddragon.leagueoflegends.com/cdn/';
        this._versions = 'https://ddragon.leagueoflegends.com/api/versions.json';
        this._initialized = false;
        this._version = undefined;
        this._region = 'na';
        this._patch = undefined;
        this._locale = 'en_US';
        this._apiKey = apiKey;
        this._cacheEnabled = { api: true, dragon: true };
        this._storageEnabled = { api: false, dragon: true };
        this._cache = new util_1.MemoryCache();
        this._storage = new util_1.LocalStorage(this, 'data');
        this._seasons = [];
        this._queues = [];
        this._maps = [];
        this._gameModes = [];
        this._gameTypes = [];
        this._champions = new managers_1.ChampionManager(this);
        this._items = new managers_1.ItemManager(this);
        this._runes = new managers_1.RuneTreeManager(this);
        this._summonerSpells = new managers_1.SummonerSpellManager(this);
        this._summoners = new managers_1.SummonerManager(this);
        this._accounts = new managers_1.AccountManager(this);
        this._leagues = new managers_1.LeagueManager(this);
        this._matches = new managers_1.MatchManager(this);
        this._spectator = new managers_1.CurrentGameManager(this);
        this._clash = new managers_1.ClashManager(this);
        this._challenges = new managers_1.ChallengeManager(this);
        this._http = axios_1.default.create({ baseURL: this._cdnBase, validateStatus: () => true });
        this._api = new ratelimiter_1.RateLimiter(this, {}, apiKey);
    }
    /**
     * Is this client initialized.
     */
    get initialized() {
        return this._initialized;
    }
    /**
     * The current Data Dragon CDN version.
     */
    get version() {
        this._ensureInitialized();
        return this._version;
    }
    /**
     * The patch of the game currently in use.
     *
     * Must be above 5.1 for proper functionality.
     */
    get patch() {
        this._ensureInitialized();
        return this._patch;
    }
    /**
     * The locale in which all the data is going to be fetched in.
     */
    get locale() {
        this._ensureInitialized();
        return this._locale;
    }
    /**
     * The league of legends region from which the data is to be fetched.
     */
    get region() {
        this._ensureInitialized();
        return this._region;
    }
    set region(region) {
        this._ensureInitialized();
        this._region = region;
    }
    /**
     * The default champions manager used by the client.
     */
    get champions() {
        this._ensureInitialized();
        return this._champions;
    }
    /**
     * The default items manager used by the client.
     */
    get items() {
        this._ensureInitialized();
        return this._items;
    }
    /**
     * The default runes manager used by the client.
     */
    get runes() {
        this._ensureInitialized();
        return this._runes;
    }
    /**
     * The default summoner spells manager used by the client.
     */
    get summonerSpells() {
        this._ensureInitialized();
        return this._summonerSpells;
    }
    /**
     * The default API interactions handler used by the client.
     */
    get api() {
        this._ensureInitialized();
        return this._api;
    }
    /**
     * An array of all seasons and their respective IDs.
     */
    get seasons() {
        this._ensureInitialized();
        return this._seasons;
    }
    /**
     * An array of all queue types and their respective data.
     */
    get queues() {
        this._ensureInitialized();
        return this._queues;
    }
    /**
     * An array of all maps and their respective data.
     */
    get maps() {
        this._ensureInitialized();
        return this._maps;
    }
    /**
     * An array of all game modes and their respective data.
     */
    get gameModes() {
        this._ensureInitialized();
        return this._gameModes;
    }
    /**
     * An array of all game types and their respective data.
     */
    get gameTypes() {
        this._ensureInitialized();
        return this._gameTypes;
    }
    /**
     * The client's logging utility.
     */
    get logger() {
        return this._logger;
    }
    /**
     * The client's caching utility.
     */
    get cache() {
        return this._cache;
    }
    /**
     * The client's storage utility.
     */
    get storage() {
        return this._storage;
    }
    /**
     * The client's configuration for storage. This is for internal usage only.
     *
     * PLEASE DO NOT TRY TO USE THIS.
     * Refer to {@link Client.initialize} to configure this.
     */
    get storageEnabled() {
        return this._storageEnabled;
    }
    /**
     * The client's configuration for caching. This is for internal usage only.
     *
     * PLEASE DO NOT TRY TO USE THIS.
     * Refer to {@link Client.initialize} to configure this.
     */
    get cacheEnabled() {
        return this._cacheEnabled;
    }
    /**
     * The axios instance that handles all the CDN requests being made.
     */
    get http() {
        this._ensureInitialized();
        return this._http;
    }
    /**
     * The Data Dragon CDN Base URL
     */
    get cdnBase() {
        this._ensureInitialized();
        return this._cdnBase;
    }
    /**
     * The default summoners manager used by the client.
     */
    get summoners() {
        this._ensureInitialized();
        return this._summoners;
    }
    /**
     * The default riot accounts manager used by the client.
     * This is mostly for internal usage. You may want to use {@link Client.summoners} instead.
     */
    get accounts() {
        this._ensureInitialized();
        return this._accounts;
    }
    /**
     * The default summoner competitive league data manager used by the client.
     *
     * Highly recommended using {@link Client.summoners} for a specific summoner's competitive info.
     *
     * Use this only if you want to query a list of users by rank-division.
     */
    get leagues() {
        this._ensureInitialized();
        return this._leagues;
    }
    /**
     * The default match manager used by the client.
     */
    get matches() {
        this._ensureInitialized();
        return this._matches;
    }
    /**
     * The default LOL challenges manager used by the client.
     */
    get challenges() {
        this._ensureInitialized();
        return this._challenges;
    }
    /**
     * The default live match manager used by the client.
     */
    get spectator() {
        this._ensureInitialized();
        return this._spectator;
    }
    /**
     * The default clash tournaments manager used by the client.
     */
    get clash() {
        this._ensureInitialized();
        return this._clash;
    }
    /**
     * Get the current status of the RIOT API.
     *
     * No type support for this (yet).
     */
    get status() {
        this._ensureInitialized();
        return new Promise(async (resolve, reject) => {
            this.logger?.trace('Fetching status from Riot API.');
            const response = await this.api
                .request('/lol/status/v4/platform-data', {
                region: this.region,
                api: 'LOL_STATUS',
                method: 'getPlatformData',
                params: 'no params',
                regional: false
            })
                .catch(reject);
            if (response)
                resolve(response.data);
        });
    }
    /**
     * Initialize the client to prepare it for interacting with the API.
     * This can also be rerun if you want to configure anything and quickly fetch any required data.
     *
     * @param options - The client configuration.
     */
    async initialize(options) {
        // Parse the basic configuration
        const region = options?.region || 'na';
        this._region = region;
        const version = options?.version || undefined;
        this._version = version;
        this._patch = version !== undefined ? version.match(patchRegex).shift() : undefined;
        const language = options?.locale || undefined;
        if (language !== undefined)
            this._locale = language;
        if (typeof options?.logger === 'boolean')
            options.logger = { enable: options.logger };
        if (typeof options?.fetch === 'boolean')
            options.fetch = {
                champions: options?.fetch,
                items: options?.fetch,
                runes: options?.fetch,
                summonerSpells: options?.fetch
            };
        // Set up the logging utility if enabled.
        const enableLogging = options?.logger?.enable ?? true;
        if (enableLogging) {
            const loggerLevel = options?.logger?.level || 'WARN';
            this._logger = options?.logger?.custom || new util_1.ShieldbowLogger(loggerLevel);
        }
        this.logger?.debug('Initializing client... logging enabled.');
        this.logger?.debug('Order: version, locale, rate limiter, cache, storage, static data.');
        // Update the client's basic configuration.
        if (version === undefined || language === undefined) {
            this.logger?.trace('Fetching latest version and locale from the API.');
            const response = await axios_1.default
                .get(region ? `https://ddragon.leagueoflegends.com/realms/${region}.json` : this._versions)
                .catch(() => { });
            if (response?.status !== 200)
                throw new Error('Unable to fetch data dragon version. Please confirm the region exists.');
            const result = response.data;
            if (Array.isArray(result)) {
                this.logger?.trace(`Using version ${version ?? result[0]} and locale en_US.`);
                this._version = version !== undefined ? version : result[0];
                this._patch = this._version.match(patchRegex).shift();
                this._locale = 'en_US';
            }
            else {
                this.logger?.trace(`Using version ${version ?? result.v} and locale ${language ?? result.l}.`);
                this._version = version !== undefined ? version : result.v;
                this._locale = language !== undefined ? language : result.l;
                this._patch = this._version.match(patchRegex).shift();
            }
            // Check if appropriate community dragon version exists
            // If it doesn't roll back to previous patch and re-initialize
            const cDragonUrl = `https://raw.communitydragon.org/${this._patch}/content-metadata.json`;
            const cDragonResponse = await axios_1.default.get(cDragonUrl).catch(() => { });
            if (cDragonResponse?.status !== 200) {
                this.logger?.warn(`Unable to fetch community dragon version for patch ${this._patch}. Rolling back to previous patch.`);
                const allVersionsResponse = await axios_1.default.get(this._versions).catch(() => { });
                if (allVersionsResponse?.status !== 200)
                    throw new Error('Unable to fetch data dragon version. Data Dragon might be down.');
                const allVersions = allVersionsResponse.data;
                const cIndex = allVersions.indexOf(this._version);
                const nIndex = cIndex < 0 ? 0 : cIndex + 1;
                const previousVersion = allVersions[nIndex];
                this.logger?.trace(`Retrying with version ${previousVersion}`);
                return await this.initialize({ ...options, version: previousVersion });
            }
        }
        this.logger?.trace('Initializing the API rate limiter.');
        this._api = new ratelimiter_1.RateLimiter(this, options?.ratelimiter ?? {}, this._apiKey);
        // Set the initialized flag to true.
        this._initialized = true;
        // If no options are provided, set the defaults for cache, storage and prefetching.
        if (typeof options === 'undefined')
            options = { fetch: false, cache: true, storage: { enable: { api: false, dragon: true } } };
        // Parse the caching configuration and set up the cache.
        this.logger?.trace('Parsing caching configuration.');
        if (typeof options.cache === 'undefined')
            options.cache = true;
        if (typeof options.cache === 'boolean')
            options.cache = { enable: options.cache };
        if (typeof options.cache.enable === 'boolean')
            options.cache.enable = { api: options.cache.enable, dragon: options.cache.enable };
        if (typeof options.cache.enable?.api === 'undefined')
            options.cache.enable.api = true;
        if (typeof options.cache.enable?.dragon === 'undefined')
            options.cache.enable.dragon = true;
        this._cacheEnabled = options.cache.enable;
        this._cache = options.cache.custom ? options.cache.custom : new util_1.MemoryCache();
        // Parse the storage configuration and set up the storage.
        this.logger?.trace('Parsing storage configuration.');
        if (typeof options.storage === 'undefined')
            options.storage = { enable: { api: false, dragon: true } };
        if (typeof options.storage === 'boolean')
            options.storage = { enable: options.storage };
        if (typeof options.storage.enable === 'boolean')
            options.storage.enable = { api: options.storage.enable, dragon: options.storage.enable };
        if (typeof options.storage.enable?.api === 'undefined')
            options.storage.enable.api = false;
        if (typeof options.storage.enable?.dragon === 'undefined')
            options.storage.enable.dragon = true;
        this._storageEnabled = options.storage.enable;
        const storageRoot = options?.storage?.root || 'data';
        this._storage = options.storage.custom ? options.storage.custom : new util_1.LocalStorage(this, storageRoot);
        // Get the game constants from data dragon (this is static data, so it's always fetched).
        this.logger?.trace('Fetching seasons static data from DDragon.');
        const seasonsResponse = await axios_1.default
            .get('https://static.developer.riotgames.com/docs/lol/seasons.json')
            .catch(() => { });
        this.logger?.trace('Fetching queues static data from DDragon.');
        const queuesResponse = await axios_1.default
            .get('https://static.developer.riotgames.com/docs/lol/queues.json')
            .catch(() => { });
        this.logger?.trace('Fetching maps static data from DDragon.');
        const mapsResponse = await axios_1.default.get('https://static.developer.riotgames.com/docs/lol/maps.json').catch(() => { });
        this.logger?.trace('Fetching game modes static data from DDragon.');
        const gameModesResponse = await axios_1.default
            .get('https://static.developer.riotgames.com/docs/lol/gameModes.json')
            .catch(() => { });
        this.logger?.trace('Fetching game types static data from DDragon.');
        const gameTypesResponse = await axios_1.default
            .get('https://static.developer.riotgames.com/docs/lol/gameTypes.json')
            .catch(() => { });
        if (seasonsResponse?.status !== 200)
            throw new Error('Unable to fetch seasons static data from data dragon.');
        if (queuesResponse?.status !== 200)
            throw new Error('Unable to fetch queues static data from data dragon.');
        if (mapsResponse?.status !== 200)
            throw new Error('Unable to fetch maps static data from data dragon.');
        if (gameModesResponse?.status !== 200)
            throw new Error('Unable to fetch game modes static data from data dragon.');
        if (gameTypesResponse?.status !== 200)
            throw new Error('Unable to fetch game types static data from data dragon.');
        this.logger?.trace('Parsing fetched static data into defined interfaces.');
        this._seasons = seasonsResponse.data;
        this._queues = queuesResponse.data.map((q) => ({
            ...q,
            notes: q.notes ?? undefined
        }));
        this._maps = mapsResponse.data.map((m) => ({
            ...m,
            image: this.cdnBase + this.version + `/img/map/map${m.mapId}.png`
        }));
        this._gameModes = gameModesResponse.data;
        this._gameTypes = gameTypesResponse.data;
        this.logger?.debug('Client initialized, now prefetching.');
        // Prefetch the data and cache it for faster data retrieval.
        this.logger?.trace('Prefetch specified data from DDragon.', options?.fetch);
        if (typeof options?.fetch === 'boolean')
            options.fetch = {
                champions: options.fetch,
                items: options.fetch,
                runes: options.fetch,
                summonerSpells: options.fetch
            };
        if (options?.fetch?.champions ?? false)
            await this.champions.fetchAll();
        if (options?.fetch?.items ?? false)
            await this.items.fetch('1001');
        if (options?.fetch?.runes ?? false)
            await this.runes.fetch('Domination');
        if (options?.fetch?.summonerSpells ?? false)
            await this.summonerSpells.fetch('SummonerFlash');
    }
    /**
     * Update the locale in which the data is fetched.
     *
     * @param newLocale - The new locale to use for the future requests.
     * @param refetch - Whether to fetch all data dragon data in the new locale right away.
     */
    async updateLocale(newLocale, refetch = true) {
        this._ensureInitialized();
        this.logger?.debug('Assigning new locale.');
        this._locale = newLocale;
        if (refetch) {
            this.logger?.debug('Re-fetching data from DDragon.');
            await this.champions.fetchAll();
            await this.items.fetch('1001');
            await this.runes.fetch('Domination');
            await this.summonerSpells.fetch('SummonerFlash');
        }
    }
    /**
     * Update the patch from which the data is fetched.
     *
     * NOTE: The patch must be 2 integers separated by a `.`.
     * For example: `10.11` or `12.9`.
     *
     * This should NOT be the data dragon version.
     *
     * @param patch - The new patch to use for the future requests.
     * @param refetch - Whether to fetch all data dragon data from the new patch right away.
     */
    async updatePatch(patch, refetch = true) {
        this._ensureInitialized();
        this.logger?.debug('Update patch and DDragon version.');
        this._patch = patch;
        this._version = patch + '.1';
        if (refetch) {
            this.logger?.debug('Re-fetching data from DDragon.');
            await this.champions.fetchAll();
            await this.items.fetch('1001');
            await this.runes.fetch('Domination');
            await this.summonerSpells.fetch('SummonerFlash');
        }
    }
    /**
     * Ensure that client was initialized
     */
    _ensureInitialized() {
        if (!this._initialized)
            throw new Error('Please initialize the client first.');
    }
}
exports.Client = Client;
//# sourceMappingURL=client.js.map