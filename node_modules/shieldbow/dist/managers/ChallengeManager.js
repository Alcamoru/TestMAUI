"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChallengeManager = void 0;
const structures_1 = require("../structures");
const collection_1 = require("@discordjs/collection");
const util_1 = require("../util");
/**
 * A challenge manager - to fetch and manage all the challenges' data.
 *
 * Requires API key with access to `lol-challenges-v1` API.
 */
class ChallengeManager {
    /**
     * Create a new challenge manager.
     * @param client - The client this challenge manager belongs to.
     */
    constructor(client) {
        /**
         * The client this challenge manager belongs to.
         */
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
    }
    /**
     * Fetch all challenges.
     * @param options - The basic fetching options (force is ignored here).
     */
    async fetchAll(options) {
        const opts = (0, util_1.parseFetchOptions)(this.client, 'challenge', options);
        const { cache, store, region } = opts;
        this.client.logger?.debug(`Fetching all challenges data with options: `, opts);
        try {
            const result = new collection_1.Collection();
            this.client.logger?.trace(`Fetching all challenges data from API`);
            const cResponse = await this.client.api.request(`/lol/challenges/v1/challenges/config`, {
                region: region,
                regional: false,
                api: 'LOL_CHALLENGES',
                method: 'getAllChallengeConfigs',
                params: ''
            });
            const pResponse = await this.client.api.request(`/lol/challenges/v1/challenges/percentiles`, {
                region: region,
                regional: false,
                api: 'LOL_CHALLENGES',
                method: 'getAllChallengePercentiles',
                params: ''
            });
            this.client.logger?.trace(`Fetched all challenges data from API, parsing, caching and storing data.`);
            const data = cResponse.data;
            const percentiles = pResponse.data;
            for (const challenge of data) {
                const percentile = percentiles[challenge.id.toString()];
                const c = new structures_1.Challenge(this.client, challenge, percentile);
                if (cache)
                    await this.client.cache.set(`challenge:${c.id}`, c);
                if (store)
                    await this.client.storage.save({ challenge, percentile }, `challenge`, c.id.toString());
                result.set(c.id, c);
            }
            return result;
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
    /**
     * Fetch a challenge by the challenge ID.
     *
     * @param id - The ID of the challenge you want to find.
     * @param options - The basic fetching options.
     */
    async fetch(id, options) {
        const opts = (0, util_1.parseFetchOptions)(this.client, 'challenge', options);
        const { ignoreCache, ignoreStorage, cache, store, region } = opts;
        this.client.logger?.debug(`Fetching challenge data for ID: ${id} with options: `, opts);
        try {
            if (!ignoreCache) {
                this.client.logger?.trace(`Fetching challenge data from cache`);
                const exists = await this.client.cache.has(`challenge:${id}`);
                if (exists)
                    return this.client.cache.get(`challenge:${id}`);
            }
            if (!ignoreStorage) {
                this.client.logger?.trace(`Fetching challenge data from storage`);
                const storage = this.client.storage.fetch('challenge', id.toString());
                const stored = storage instanceof Promise ? await storage.catch(() => undefined) : storage;
                if (stored) {
                    const result = new structures_1.Challenge(this.client, stored.challenge, stored.percentile);
                    if (cache)
                        await this.client.cache.set(`challenge:${id}`, result);
                    return result;
                }
            }
            this.client.logger?.trace(`Fetching challenge data from the API`);
            const cResponse = await this.client.api.request(`/lol/challenges/v1/challenges/${id}/config`, {
                region: region,
                regional: false,
                api: 'LOL_CHALLENGES',
                method: 'getChallengeConfigs',
                params: `Challenge ID: ${id}`
            });
            const pResponse = await this.client.api.request(`/lol/challenges/v1/challenges/${id}/percentiles`, {
                region: region,
                regional: false,
                api: 'LOL_CHALLENGES',
                method: 'getChallengePercentiles',
                params: `Challenge ID: ${id}`
            });
            this.client.logger?.trace(`Challenge data fetched from the API, parsing, caching and storing data.`);
            const data = cResponse.data;
            const percentile = pResponse.data;
            const challenge = new structures_1.Challenge(this.client, data, percentile);
            if (cache)
                await this.client.cache.set(`challenge:${id}`, challenge);
            if (store)
                await this.client.storage.save({ challenge: data, percentile }, 'challenge', id.toString());
            return Promise.resolve(challenge);
        }
        catch (e) {
            return Promise.reject(e);
        }
    }
    /**
     * Fetch the leader board of a challenge.
     * @param id - The ID of the challenge whose leaderboard you want to find.
     * @param level - The tier of the leaderboard.
     * @param options - The basic fetching options, with an additional limit option. Limit (or count) is 200 by default.
     */
    async fetchLeaderboard(id, level, options) {
        const opts = (0, util_1.parseFetchOptions)(this.client, 'challenge', options);
        const { ignoreCache, ignoreStorage, cache, store, region } = opts;
        const limit = options?.limit ?? 200;
        this.client.logger?.debug(`Fetching challenge leaderboard for challenge ID: ${id}, level: ${level} with options: `, opts);
        try {
            const key = `challenge-leaderboard:${id}:${level}`;
            if (!ignoreCache) {
                this.client.logger?.trace(`Fetching challenge leaderboard data from cache`);
                const exists = await this.client.cache.has(`${key}:${region}`);
                if (exists)
                    return Promise.resolve(await this.client.cache.get(`${key}:${region}`));
            }
            if (!ignoreStorage) {
                this.client.logger?.trace(`Fetching challenge leaderboard data from storage`);
                const storage = this.client.storage.fetch(key, region);
                const stored = storage instanceof Promise ? await storage.catch(() => undefined) : storage;
                if (stored) {
                    const result = stored.map((data) => new structures_1.ChallengeRank(this.client, data, level));
                    if (cache)
                        await this.client.cache.set(`${key}:${region}`, result);
                    return Promise.resolve(result);
                }
            }
            this.client.logger?.trace(`Fetching challenge leaderboard data from the API`);
            const response = await this.client.api.request(`/lol/challenges/v1/challenges/${id}/leaderboards/by-level/${level}?limit=${limit}`, {
                region: region,
                regional: false,
                api: 'LOL_CHALLENGES',
                method: 'getChallengeLeaderboards',
                params: `Challenge ID: ${id}, Level: ${level}`
            });
            this.client.logger?.trace(`Challenge leaderboard data fetched from the API, parsing, caching and storing data.`);
            const data = response.data;
            const result = data.map((d) => new structures_1.ChallengeRank(this.client, d, level));
            if (cache)
                await this.client.cache.set(`${key}:${region}`, result);
            if (store)
                await this.client.storage.save(data, key, region);
            return Promise.resolve(result);
        }
        catch (e) {
            return Promise.reject(e);
        }
    }
    /**
     * Fetch the progress of a summoner in the challenges.
     * @param playerId - The player ID (puuid) of the summoner whose progress you want to find.
     * @param options - The basic fetching options.
     */
    async fetchSummonerProgression(playerId, options) {
        const opts = (0, util_1.parseFetchOptions)(this.client, 'challenge', options);
        const { ignoreCache, ignoreStorage, cache, store, region } = opts;
        this.client.logger?.debug(`Fetching challenges progression for summoner ID: ${playerId} with options: `, opts);
        try {
            if (!ignoreCache) {
                this.client.logger?.trace(`Fetching challenge progression data from cache`);
                const exists = await this.client.cache.has(`challenge-progression:${playerId}`);
                if (exists)
                    return Promise.resolve(await this.client.cache.get(`challenge-progression:${playerId}`));
            }
            if (!ignoreStorage) {
                this.client.logger?.trace(`Fetching challenge progression data from storage`);
                const storage = this.client.storage.fetch('challenge-progression', playerId);
                const stored = storage instanceof Promise ? await storage.catch(() => undefined) : storage;
                if (stored) {
                    const result = new structures_1.SummonerChallenge(this.client, stored);
                    if (cache)
                        await this.client.cache.set(`challenge-progression:${playerId}`, result);
                    return Promise.resolve(result);
                }
            }
            this.client.logger?.trace(`Fetching challenge progression data from the API`);
            const response = await this.client.api.request(`/lol/challenges/v1/player-data/${playerId}`, {
                region: region,
                regional: false,
                api: 'LOL_CHALLENGES',
                method: 'getPlayerData',
                params: `Summoner ID: ${playerId}`
            });
            this.client.logger?.trace(`Challenge progression data fetched from the API, parsing, caching and storing data.`);
            const data = response.data;
            const result = new structures_1.SummonerChallenge(this.client, data);
            if (cache)
                await this.client.cache.set(`challenge-progression:${playerId}`, result);
            if (store)
                await this.client.storage.save(data, 'challenge-progression', playerId);
            return Promise.resolve(result);
        }
        catch (e) {
            return Promise.reject(e);
        }
    }
}
exports.ChallengeManager = ChallengeManager;
//# sourceMappingURL=ChallengeManager.js.map