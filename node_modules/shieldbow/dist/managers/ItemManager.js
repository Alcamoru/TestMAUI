"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ItemManager = void 0;
const structures_1 = require("../structures");
const util_1 = require("../util");
const collection_1 = require("@discordjs/collection");
/**
 * An item manager - to fetch and manage all item data.
 *
 * Does not require an API Key.
 */
class ItemManager {
    /**
     * Create a new item manager.
     *
     * @param client - The client this item manager belongs to.
     */
    constructor(client) {
        /**
         * The client this item manager belongs to.
         */
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
    }
    /**
     * Fetch all items.
     * @param options - The basic fetching options.
     */
    async fetchAll(options) {
        const opts = (0, util_1.parseFetchOptions)(this.client, 'items', options);
        const { cache } = opts;
        this.client.logger?.trace('Fetching all items');
        try {
            const items = await this._fetchLocalItems(opts);
            const result = new collection_1.Collection();
            for (const key of Object.keys(items)) {
                const item = new structures_1.Item(this.client, key, items[key]);
                result.set(key, item);
                if (cache)
                    await this.client.cache.set(`item:${key}`, item);
            }
            return result;
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
    /**
     * Fetch an item by its 4-digit ID. The ID must be a string of 4 digits (not a number)
     *
     * @param key - The ID of the item to fetch.
     * @param options - The basic fetching options.
     */
    async fetch(key, options) {
        const opts = (0, util_1.parseFetchOptions)(this.client, 'items', options);
        const { ignoreCache } = opts;
        this.client.logger?.trace(`Fetching item ${key}`);
        try {
            if (!ignoreCache) {
                const exists = await this.client.cache.has(`item:${key}`);
                if (exists)
                    return this.client.cache.get(`item:${key}`);
            }
            const items = await this.fetchAll(opts);
            if (items && items.has(key))
                return items.get(key);
            else
                return Promise.reject('There is no item with that ID');
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
    /**
     * Fetch an item by its name.
     * The search is case-insensitive.
     * The special characters are NOT ignored.
     *
     * @param name - The name of the item to look for.
     * @param options - The basic fetching options.
     */
    async fetchByName(name, options) {
        const opts = (0, util_1.parseFetchOptions)(this.client, 'items', options);
        const item = await this.client.cache.find((item) => item.name.toLowerCase().includes(name.toLowerCase()));
        if (item)
            return item;
        const items = await this.fetchAll(opts);
        return items.find((i) => i.name.toLowerCase().includes(name.toLowerCase()));
    }
    /**
     * Fetch multiple items at once.
     *
     * @param keys - The keys of the items to fetch.
     * @param options - The basic fetching options.
     */
    async fetchMany(keys, options) {
        const opts = (0, util_1.parseFetchOptions)(this.client, 'items', options);
        const { cache } = opts;
        this.client.logger?.trace(`Fetching items ${keys.join(', ')}`);
        try {
            const result = new collection_1.Collection();
            for (const key of keys) {
                const item = await this.fetch(key, opts);
                if (item)
                    result.set(key, item);
                if (cache)
                    await this.client.cache.set(`item:${key}`, item);
            }
            return result;
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
    async _fetchLocalItems(options) {
        const storagePath = ['items', this.client.patch, this.client.locale].join(':');
        if (!options.ignoreStorage) {
            this.client.logger?.trace('Fetching items from storage');
            // This needs to be slightly modified to work with the new storage system.
            const data = this.client.storage.fetch(storagePath, 'items');
            const result = data instanceof Promise ? await data.catch(() => undefined) : data;
            if (result)
                return result.data;
        }
        try {
            this.client.logger?.trace('Fetching items from DDragon');
            const response = await this.client.http.get(`${this.client.version}/data/${this.client.locale}/item.json`);
            if (response.status !== 200)
                return Promise.reject('Unable to fetch items from Data dragon');
            else {
                if (options.store)
                    await this.client.storage.save({ data: response.data.data }, storagePath, 'items');
                return response.data.data;
            }
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
}
exports.ItemManager = ItemManager;
//# sourceMappingURL=ItemManager.js.map