"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CurrentGameManager = void 0;
const structures_1 = require("../structures");
const util_1 = require("../util");
/**
 * A current game manager - to fetch and manage the live games.
 *
 * Requires API key with access to `spectator-v4` API.
 */
class CurrentGameManager {
    /**
     * Creates a new current game manager.
     * @param client - The client this current game manager belongs to.
     */
    constructor(client) {
        /**
         * The client this current game manager belongs to.
         */
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
    }
    /**
     * Fetches the live game for the given summoner ID.
     *
     * @param id - The summoner ID to fetch the live game for.
     * @param options - The basic fetching options.
     */
    async fetch(id, options) {
        const opts = (0, util_1.parseFetchOptions)(this.client, 'currentGame', options);
        const { ignoreCache, ignoreStorage, cache, store, region } = opts;
        this.client.logger?.debug(`Fetching live game ${id} with options: `, opts);
        try {
            if (!ignoreCache) {
                this.client.logger?.trace(`Checking cache for live game`);
                const exists = await this.client.cache.has(`spectator:${id}`);
                if (exists)
                    return this.client.cache.get(`spectator:${id}`);
            }
            const runeTrees = await this.client.runes.fetchAll();
            const spells = await this.client.summonerSpells.fetchAll();
            if (!ignoreStorage) {
                this.client.logger?.trace(`Checking storage for live game`);
                const storage = this.client.storage.fetch('spectator', id);
                const stored = storage instanceof Promise ? await storage.catch(() => undefined) : storage;
                if (stored) {
                    this.client.logger?.trace(`Live game found, parsing data and returning...`);
                    const champs = await this.client.champions.fetchByKeys(stored.participants.map((p) => p.championId));
                    const banned = await this.client.champions.fetchByKeys(stored.bannedChampions.map((b) => b.championId));
                    const result = new structures_1.CurrentGame(this.client, stored, banned.concat(champs), runeTrees, spells);
                    if (cache)
                        await this.client.cache.set(`spectator:${id}`, result);
                    return result;
                }
            }
            this.client.logger?.trace(`No live game found in cache or storage, fetching from API...`);
            const response = await this.client.api.request('/lol/spectator/v4/active-games/by-summoner/' + id, {
                region: region,
                regional: false,
                api: 'SPECTATOR',
                method: 'getCurrentGameInfoBySummoner',
                params: 'Summoner ID: ' + id
            });
            this.client.logger?.trace(`Live game fetched, parsing data and returning...`);
            const data = response.data;
            const champs = await this.client.champions.fetchByKeys(data.participants.map((p) => p.championId));
            const banned = await this.client.champions.fetchByKeys(data.bannedChampions.map((b) => b.championId));
            const game = new structures_1.CurrentGame(this.client, data, champs.concat(banned), runeTrees, spells);
            if (cache)
                await this.client.cache.set(`spectator:${id}`, game);
            if (store)
                await this.client.storage.save(data, 'spectator', id);
            return game;
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
    /**
     * Fetch a list of featured games.
     *
     * @param options - The basic fetching options (does not fetch from storage or cache).
     */
    async fetchFeatured(options) {
        const opts = (0, util_1.parseFetchOptions)(this.client, 'currentGame', options);
        const { region, cache, store } = opts;
        this.client.logger?.debug(`Fetching featured live games with options: `, opts);
        try {
            this.client.logger?.trace(`Fetching featured live games from API...`);
            const response = await this.client.api.request('/lol/spectator/v4/featured-games', {
                region: region,
                regional: false,
                api: 'SPECTATOR',
                method: 'getFeaturedGames',
                params: 'no params'
            });
            this.client.logger?.trace(`Featured live games fetched, fetching relevant ddragon data...`);
            const data = response.data;
            const runeTrees = await this.client.runes.fetchAll();
            const spells = await this.client.summonerSpells.fetchAll();
            this.client.logger?.trace(`Parsing data and returning...`);
            const games = [];
            for (const game of data.gameList) {
                const participantChamps = await this.client.champions.fetchByKeys(game.participants.map((p) => p.championId));
                const bannedChamps = await this.client.champions.fetchByKeys(game.bannedChampions.map((b) => b.championId));
                games.push(new structures_1.CurrentGame(this.client, game, bannedChamps.concat(participantChamps), runeTrees, spells));
                if (cache)
                    await this.client.cache.set(`spectator:${game.gameId}`, games[games.length - 1]);
                if (store)
                    await this.client.storage.save(game, 'spectator', game.gameId.toString());
            }
            return games;
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
}
exports.CurrentGameManager = CurrentGameManager;
//# sourceMappingURL=CurrentGameManager.js.map