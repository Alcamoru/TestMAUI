"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountManager = void 0;
const structures_1 = require("../structures");
const util_1 = require("../util");
/**
 * An account manager - to fetch and manage all the RIOT accounts.
 *
 * Requires API key with access to `account-v1` API.
 */
class AccountManager {
    /**
     * Creates a new account manager.
     * @param client - The client this account manager belongs to.
     */
    constructor(client) {
        /**
         * The client this account manager belongs to.
         */
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
    }
    /**
     * Fetch a RIOT account by its unique PUUID.
     *
     * @param id - The PUUID of the RIOT account.
     * @param options - The basic fetching options.
     */
    async fetch(id, options) {
        const opts = (0, util_1.parseFetchOptions)(this.client, 'account', options);
        const { ignoreCache, ignoreStorage, cache, store } = opts;
        const region = options?.region ?? this.client.region;
        this.client.logger?.debug(`Fetching account data for ID: ${id} with options: `, opts);
        try {
            if (!ignoreCache) {
                this.client.logger?.trace(`Checking cache for account with ID: ${id}`);
                const exists = await this.client.cache.has(`account:${id}`);
                if (exists)
                    return this.client.cache.get(`account:${id}`);
            }
            if (!ignoreStorage) {
                this.client.logger?.trace(`Checking storage for account with ID: ${id}`);
                const storage = this.client.storage.fetch('account', id);
                const stored = storage instanceof Promise ? await storage.catch(() => undefined) : storage;
                if (stored) {
                    const account = new structures_1.Account(stored);
                    if (cache)
                        await this.client.cache.set(`account:${id}`, account);
                    return account;
                }
            }
            this.client.logger?.trace(`Fetching account from API with ID: ${id}`);
            const response = await this.client.api.request('/riot/account/v1/accounts/by-puuid/' + id, {
                region,
                regional: true,
                api: 'ACCOUNT',
                method: 'getByPuuid',
                params: 'PUUID: ' + id
            });
            this.client.logger?.trace(`Account found, creating new Account instance.`);
            const accountData = response.data;
            const account = new structures_1.Account(accountData);
            this.client.logger?.trace(`Caching, storing and returning account (according to options).`);
            if (cache)
                await this.client.cache.set(`account:${id}`, account);
            if (store)
                await this.client.storage.save(accountData, 'account', account.playerId);
            return account;
        }
        catch (e) {
            return Promise.reject(e);
        }
    }
    /**
     * Fetch a RIOT account by its name and tag.
     *
     * @param name - The name of this RIOT account.
     * @param tag - The tag of this RIOT account.
     * @param options - The basic fetching options.
     */
    async fetchByNameAndTag(name, tag, options) {
        const opts = (0, util_1.parseFetchOptions)(this.client, 'account', options);
        const { ignoreCache, ignoreStorage, cache, store, region } = opts;
        this.client.logger?.debug(`Fetching account for name#tag: ${name}#${tag} with options: `, opts);
        try {
            if (!ignoreCache) {
                this.client.logger?.trace(`Checking cache for account with name#tag: ${name}#${tag}`);
                const cached = await this.client.cache.find((a) => a.username === name && a.userTag === tag);
                if (cached)
                    return cached;
            }
            if (!ignoreStorage) {
                this.client.logger?.trace(`Checking storage for account with name#tag: ${name}#${tag}`);
                const stored = await this.client.storage.search('account', { gameName: name, tagLine: tag });
                if (stored.length > 0) {
                    const account = new structures_1.Account(stored[0]);
                    if (cache)
                        await this.client.cache.set(`account:${account.playerId}`, account);
                    return account;
                }
            }
            this.client.logger?.trace(`Fetching account from API with name#tag: ${name}#${tag}`);
            const accountResponse = await this.client.api.request('/riot/account/v1/accounts/by-riot-id/' + encodeURIComponent(name) + '/' + tag, {
                region: region,
                regional: true,
                api: 'ACCOUNT',
                method: 'getByRiotId',
                params: 'NAME: ' + name + ', TAG: ' + tag
            });
            this.client.logger?.trace(`Account found, creating new Account instance.`);
            const accountData = accountResponse.data;
            const account = new structures_1.Account(accountData);
            this.client.logger?.trace(`Caching, storing and returning account (according to options).`);
            if (cache)
                await this.client.cache.set(`account:${account.playerId}`, account);
            if (store)
                await this.client.storage.save(accountData, 'account', account.playerId);
            return account;
        }
        catch (e) {
            return Promise.reject(e);
        }
    }
}
exports.AccountManager = AccountManager;
//# sourceMappingURL=AccountManager.js.map