"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RateLimiter = void 0;
const tslib_1 = require("tslib");
const parseOptions_1 = tslib_1.__importDefault(require("./parseOptions"));
const parseHeaders_1 = require("./parseHeaders");
const axios_1 = tslib_1.__importDefault(require("axios"));
const error_1 = require("./error");
const util_1 = require("../util");
const axios_retry_1 = tslib_1.__importDefault(require("axios-retry"));
const requestQueue_1 = require("./requestQueue");
/**
 * The rate limiter class.
 * Used to send requests to the API.
 */
class RateLimiter {
    constructor(client, options, apiKey) {
        Object.defineProperty(this, "appLimit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "methodLimit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "throw", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "strategy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_http", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_queue", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new requestQueue_1.RequestQueue()
        });
        const config = (0, parseOptions_1.default)(options);
        this.client = client;
        this.appLimit = config.appLimit;
        this.methodLimit = config.methodLimit;
        this.throw = config.throw;
        this.strategy = config.strategy;
        this._http = axios_1.default.create({
            headers: {
                'X-Riot-Token': apiKey,
                'Content-Type': 'application/json'
            },
            responseType: 'json',
            validateStatus: () => true
        });
        (0, axios_retry_1.default)(this._http, {
            retries: config.retry.retries,
            retryDelay: () => config.retry.retryDelay
        });
    }
    /**
     * Send a request to the API.
     * @param url - The URL to send the request to.
     * @param options - The request options.
     */
    async request(url, options) {
        return await this._queue.enqueue(this.requestFromApi.bind(this, url, options));
    }
    async requestFromApi(url, options) {
        const request = `${options.api}:${options.method} (${options.params})`;
        this.client.logger?.trace(`Request URL: '${url}' - intention: ${request}`);
        return new Promise(async (resolve, reject) => {
            const check = await this._check(options.api, options.method).catch((e) => {
                throw e;
            });
            if (check.limited && this.throw)
                reject(new error_1.ApiError(429, url, this._http.defaults.headers.get, error_1.mockRatelimitedResponse));
            else if (check.limited && !this.throw)
                setTimeout(async () => {
                    this.client.logger?.debug(`Request was ratelimited. Retrying in ${check.delay}ms.`);
                    const response = await this.request(url, options).catch(reject);
                    if (response)
                        resolve(response);
                }, check.delay);
            else {
                this.client.logger?.trace(`Making the request - ${request}`);
                const base = options.regional ? util_1.regionalURLs[options.region] : util_1.apiBaseURLs[options.region];
                setTimeout(async () => {
                    const response = await this._http.get(base + url);
                    this.client.logger?.trace(`Request response:`, response.status);
                    await this._updateFromHeaders(response.headers, options.api, options.method);
                    if (response.status !== 200)
                        reject(new error_1.ApiError(response.status, base + url, this._http.defaults.headers.get, response));
                    else
                        resolve(response);
                }, check.delay);
            }
        });
    }
    async _check(api, method) {
        const appLimit = await this._checkAppLimit();
        const methodLimit = await this._checkMethodLimit(api, method);
        if (appLimit?.limited || methodLimit?.limited)
            return {
                limited: true,
                delay: Math.max(appLimit.delay, methodLimit.delay)
            };
        return { limited: false, delay: Math.max(appLimit?.delay, methodLimit?.delay, 0) };
    }
    async _checkAppLimit() {
        const appLimits = await this._fetchAppLimitUsage();
        this.client.logger?.trace(`Current time: ${Date.now()}, Cached limits:`, appLimits);
        const now = Date.now();
        if (!this.appLimit.length)
            return { limited: false, delay: 0 };
        const appLimit = this.appLimit.map((limit) => {
            const usage = appLimits.filter((time) => time >= now - limit.duration);
            const limited = usage.length >= limit.limit;
            return { limited, delay: this._calculateSpreadDelay(limit, usage) };
        });
        this.client.logger?.trace(`Processed limits:`, appLimits);
        const limited = appLimit.filter((limit) => limit.limited);
        this.client.logger?.trace(`Filtered limits:`, limited);
        if (limited.length > 0)
            return limited.sort((a, b) => b.delay - a.delay)[0];
        return appLimit.sort((a, b) => a.delay - b.delay)[0];
    }
    async _checkMethodLimit(api, method) {
        const methodLimits = await this._fetchMethodLimitUsage(api, method);
        const now = Date.now();
        if (!this.methodLimit[api][method].length)
            return { limited: false, delay: 0 };
        const methodLimit = this.methodLimit[api][method]
            .map((limit) => {
            const usage = methodLimits.filter((time) => time >= now - limit.duration);
            const limited = usage.length >= limit.limit;
            return { limited, delay: this._calculateSpreadDelay(limit, usage) };
        })
            .sort((a, b) => a.delay - b.delay);
        return methodLimit[0];
    }
    async _updateFromHeaders(headers, api, method) {
        const limits = (0, parseHeaders_1.parseHeaders)(headers);
        this.client?.logger?.debug(`Parsed limits (from headers):`, limits);
        const { app: appUsage, method: methodUsage } = limits.usage;
        if (limits.app.length > 0)
            this.appLimit = limits.app;
        if (limits.method.length > 0)
            this.methodLimit[api][method] = limits.method;
        if (appUsage.length < 1 && methodUsage.length < 1)
            await this._update(api, method);
        else {
            await this.client.cache.set('limits:app:usage', appUsage);
            await this.client.cache.set(`limits:method:${api}:${method}:usage`, methodUsage);
        }
    }
    async _update(api, method) {
        const appLimits = await this._fetchAppLimitUsage();
        const methodLimits = await this._fetchMethodLimitUsage(api, method);
        this.client.logger?.trace(`Old limits:`, appLimits);
        appLimits.push(Date.now());
        methodLimits.push(Date.now());
        this.client.logger?.trace(`New limits:`, appLimits);
        const oldestApp = Math.max(...this.appLimit.map((l) => l.duration));
        const oldestMethod = Math.max(...this.methodLimit[api][method].map((l) => l.duration));
        this.client.logger?.trace(`Filtered new limits:`, appLimits.filter((time) => time >= Date.now() - oldestApp));
        await this.client.cache.set('limits:app:usage', appLimits.filter((time) => time >= Date.now() - oldestApp));
        await this.client.cache.set(`limits:method:${method}:usage`, methodLimits?.filter((time) => time >= Date.now() - oldestMethod));
    }
    _calculateSpreadDelay(l, usage) {
        const used = usage.length;
        if (used >= l.limit)
            return l.duration - (Date.now() - usage[0]);
        else if (used < 1 || this.strategy === 'burst')
            return 0;
        else
            return l.duration / (l.limit - used);
    }
    async _fetchAppLimitUsage() {
        const appLimits = await this.client.cache.get('limits:app:usage');
        return appLimits ?? [];
    }
    async _fetchMethodLimitUsage(api, method) {
        const methodLimits = await this.client.cache.get(`limits:method:${api.toLowerCase()}:${method}:usage`);
        return methodLimits ?? [];
    }
}
exports.RateLimiter = RateLimiter;
//# sourceMappingURL=limiter.js.map