"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CurrentGame = void 0;
const collection_1 = require("@discordjs/collection");
const CurrentGameTeam_1 = require("./CurrentGameTeam");
/**
 * A representation of an ongoing game.
 */
class CurrentGame {
    /**
     * Create a new Current Game instance.
     * @param client - The client that requested this data.
     * @param data - The raw current game data from the API.
     * @param champions - The champions that are involved in the game.
     * @param runeTrees - The collection of the runes in the game.
     * @param summonerSpells - The collection of the summoner spells in the game.
     */
    constructor(client, data, champions, runeTrees, summonerSpells) {
        /**
         * The numerical ID of the game.
         *
         * Combining this with the {@link CurrentGame.platform} gives the full ID of the game.
         * The full ID can be used to fetch all the details of the match after it has ended using {@link MatchManager.fetch}.
         */
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The type of game.
         */
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The time at which the game started.
         */
        Object.defineProperty(this, "startTimestamp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The map on which the game is being played.
         */
        Object.defineProperty(this, "map", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The amount of time (in seconds) that has passed since the game started.
         */
        Object.defineProperty(this, "length", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The platform (server) on which the game is being played.
         */
        Object.defineProperty(this, "platform", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The game mode.
         */
        Object.defineProperty(this, "mode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The type of queue for the game.
         */
        Object.defineProperty(this, "queue", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * A collection of the participating teams.
         */
        Object.defineProperty(this, "teams", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The observer key for the game.
         */
        Object.defineProperty(this, "observerKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.id = data.gameId;
        this.type = client.gameTypes.find((t) => t.gametype === data.gameType);
        this.startTimestamp = data.gameStartTime;
        this.map = client.maps.find((m) => m.mapId === data.mapId);
        this.length = data.gameLength;
        this.platform = data.platformId;
        this.mode = client.gameModes.find((m) => m.gameMode === data.gameMode);
        this.queue = client.queues.find((q) => q.queueId === data.gameQueueConfigId);
        this.teams = new collection_1.Collection();
        this.observerKey = data.observers.encryptionKey;
        this.teams.set('blue', new CurrentGameTeam_1.CurrentGameTeam(client, data.bannedChampions.filter((c) => c.teamId === 100), data.participants.filter((p) => p.teamId === 100), champions, runeTrees, summonerSpells));
        this.teams.set('red', new CurrentGameTeam_1.CurrentGameTeam(client, data.bannedChampions.filter((c) => c.teamId === 200), data.participants.filter((p) => p.teamId === 200), champions, runeTrees, summonerSpells));
    }
    /**
     * The match ID for fetching the match details after the game is over.
     */
    get matchId() {
        return `${this.platform.toUpperCase()}_${this.id}`;
    }
}
exports.CurrentGame = CurrentGame;
//# sourceMappingURL=CurrentGame.js.map